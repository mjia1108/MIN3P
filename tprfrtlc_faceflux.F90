!*****Revision Informations Automatically Generated by VisualSVN*****!
!---------------------------------------------------------------------
!> $ID:$
!> $Revision: 545 $
!> $Author: dsu $
!> $Date: 2017-11-27 17:15:52 -0800 (Mon, 27 Nov 2017) $
!> $URL: https://biot.eos.ubc.ca/svn/min3p_thcm/branches/dsu_dual_permeability/src/min3p/tprfrtlc_faceflux.F90 $
!---------------------------------------------------------------------
!********************************************************************!

!c ----------------------------------------------------------------------
!c subroutine tprfvs
!c -----------------
!c
!c write transient data of interface flux for aqueous species 
!c to output file
!c
!c written by:      Danyang Su - Nov 27, 2017
!c
!c last modified:   -
!c
!c definition of variables:
!c
!c I --> on input   * arbitrary  - initialized  + entries expected
!c O --> on output  * arbitrary  - unaltered    + altered
!c   
!c                                                                    I O
!c
!c passed:   integer*4:
!c           ----------
!c           ivol               = pointer to current control volume   + -
!c           jvol               = pointer to current control volume   + -
!c
!c common:
!c gen.f:    real*8:
!c           -------
!c
!c           logical:
!c           --------
!c
!c
!c local:    real*8:
!c           ------- 
!c
!c 
!c --------------------------------------------------------------------------

      subroutine tprfrtlc_faceflux(ivol,jvol,igb,ngb_tstep)
 
      use gen, only : ngb_vol_ijface_jtemp, xg, yg, zg,nfloatbit,      &
                      realbuffer_gb, igcvel, offset_igcvel,            &
                      ngb_vol_ijface_area, offset_igcvel_ijk,          &
                      ngb_vol_ijface_velratio, time_io, n,             &
                      cnew, cx, vel_lin, totcnew, cinfrt_va,           &
                      cinfrt_da, cinfvs_a, pornew, sanew,              &
                      b_output_trans_binary
      use multidiff, only : multi_diff, totviscnew, mdiff_ic_cvol,     &
                            mdiff_ix_cvol, electromignew, cinfrt_mcd
      use dual, only : dual_permeability, mat_frac_face_y
      use module_binary_mpiio, only : binary_write_data

      implicit none
#ifdef PETSC_V3_6_X
#include <petsc/finclude/petscsys.h>
#elif PETSC
#include <finclude/petscsys.h>
#endif
      
      integer :: ivol, jvol, jtemp, igb, ngb_tstep
      
      !c local variables
      integer :: i1, nvars, ic
      real*8 :: areai, velxratio, velyratio, velzratio,                &
                aflux_adv, aflux_dif, aflux_mig, aflux_tot,            &
                vela_adv, vela_dif, vela_mig, vela_tot,                &
                vela_adv_x, vela_dif_x, vela_mig_x, vela_tot_x,        &
                vela_adv_y, vela_dif_y, vela_mig_y, vela_tot_y,        &
                vela_adv_z, vela_dif_z, vela_mig_z, vela_tot_z
      character*1 :: iups   
      real*8, parameter :: r0 = 0.0d0, r1 = 1.0d0      
      real*8 :: fluxv_vl, fluxd, fluxv_vl_dp, fluxd_dp
      external totdyvisc, elecmigration, fluxv_vl, fluxd,              &
               fluxv_vl_dp, fluxd_dp
      
      i1 = ngb_vol_ijface_jtemp(igb)
      
      areai = ngb_vol_ijface_area(igb)
      velxratio = ngb_vol_ijface_velratio(1,igb)
      velyratio = ngb_vol_ijface_velratio(2,igb)
      velzratio = ngb_vol_ijface_velratio(3,igb)

!c compute flux along the control volume interface
      if (multi_diff) then  
        call totdyvisc(cnew(:,ivol),cx(:,ivol),totviscnew(:,ivol),     &
                       mdiff_ic_cvol(:,i1),mdiff_ix_cvol(:,i1))

        call totdyvisc(cnew(:,jvol),cx(:,jvol),totviscnew(:,jvol),     &
                       mdiff_ic_cvol(:,i1),mdiff_ix_cvol(:,i1))

        call elecmigration(cnew(:,ivol),cx(:,ivol),cnew(:,jvol),       &
                           cx(:,jvol),mdiff_ic_cvol(:,i1),             &
                           mdiff_ix_cvol(:,i1),electromignew(:,ivol),  &
                           vel_lin(i1),ivol) 
      endif
      
      
      do ic = 1, n

        aflux_adv = r0
        aflux_dif = r0
        aflux_mig = r0
        aflux_tot = r0
!c  compute aqueous phase flux

        if (multi_diff) then 

          aflux_adv = fluxv_vl(totcnew(ic,ivol),                       &    !advective term
                               totcnew(ic,jvol),                       &
                               ivol,jvol,cinfrt_va(i1),ic)             
          aflux_dif = - fluxd(totviscnew(ic,ivol),                     &    !diffusive term
                              totviscnew(ic,jvol),                     &
                              cinfrt_mcd(i1))                          
          aflux_mig = - fluxd(electromignew(ic,ivol),r0,               &    !diffumigration 
                              cinfrt_mcd(i1))              
        else

!c ---------------- fick's law, business as usual -------------------------     

          if (.not.dual_permeability) then
            aflux_adv = fluxv_vl(totcnew(ic,ivol),                     &    !advective term
                                 totcnew(ic,jvol),                     &
                                 ivol,jvol,                            &
                                 cinfrt_va(i1),ic)                     
            aflux_dif = - fluxd(totcnew(ic,ivol),                      &    !dispersive term
                                totcnew(ic,jvol),                      &
                                cinfrt_da(i1))                     
          else                                                         
            !if (dabs(yg(ivol)-yg(jvol)).gt.small) then                
            if ((yg(ivol) > mat_frac_face_y .and.                      &
                 yg(jvol) < mat_frac_face_y) .or.                      &
                (yg(ivol) < mat_frac_face_y .and.                      &
                 yg(jvol) > mat_frac_face_y)) then                     
              aflux_adv = fluxv_vl_dp(totcnew(ic,ivol),                &    !advective term
                                      totcnew(ic,jvol),                &
                                      ivol,jvol,                       &
                                      cinfrt_va(i1),ic)                 
              aflux_dif = - fluxd_dp(totcnew(ic,ivol),                 &    !dispersive term
                                     totcnew(ic,jvol),                 &
                                     cinfrt_da(i1),                    &
                                     cinfvs_a(i1),                     &
                                     pornew(ivol),sanew(ivol),         &
                                     pornew(jvol),sanew(jvol),         &
                                     yg(ivol),yg(jvol))                
            else                                                       
              aflux_adv = fluxv_vl(totcnew(ic,ivol),                   &    !advective term
                                   totcnew(ic,jvol),                   &
                                   ivol,jvol,                          &
                                   cinfrt_va(i1),ic)                 
              aflux_dif = - fluxd(totcnew(ic,ivol),                    &    !dispersive term
                                     totcnew(ic,jvol),                 &
                                     cinfrt_da(i1))
            end if
          end if
             
        end if

!c  total flux

        aflux_tot = aflux_adv + aflux_dif + aflux_mig
        
!c  velocity is the flux (m^3/day) divided
!c  by the interfacial area between the two control volumes

        vela_adv = aflux_adv / areai * 1.0d+3
        vela_dif = aflux_dif / areai * 1.0d+3
        vela_mig = aflux_mig / areai * 1.0d+3
        vela_tot = aflux_tot / areai * 1.0d+3
        
        vela_adv_x = vela_adv * velxratio
        vela_adv_y = vela_adv * velyratio
        vela_adv_z = vela_adv * velzratio
        
        vela_dif_x = vela_dif * velxratio
        vela_dif_y = vela_dif * velyratio
        vela_dif_z = vela_dif * velzratio
        
        vela_mig_x = vela_mig * velxratio
        vela_mig_y = vela_mig * velyratio
        vela_mig_z = vela_mig * velzratio
        
        vela_tot_x = vela_tot * velxratio
        vela_tot_y = vela_tot * velyratio
        vela_tot_z = vela_tot * velzratio

!c  write data back to file
        if (b_output_trans_binary) then
          nvars = 13 
          realbuffer_gb(1:nvars)= (/time_io,                           &
                                    vela_adv_x,vela_adv_y,vela_adv_z,  &
                                    vela_dif_x,vela_dif_y,vela_dif_z,  &
                                    vela_mig_x,vela_mig_y,vela_mig_z,  &
                                    vela_tot_x,vela_tot_y,vela_tot_z/)
          
          call binary_write_data(igcvel(ic,igb), 1, (/ngb_tstep/),     &
                      offset_igcvel_ijk(ic,igb),.true.)
          call binary_write_data(igcvel(ic,igb), nvars, realbuffer_gb, &
                      offset_igcvel(ic,igb),.true.) 
        
          offset_igcvel(ic,igb) = offset_igcvel(ic,igb) + nvars*nfloatbit
        else
          write(igcvel(ic,igb),'(13e15.6e3)') time_io,                 &
                            vela_adv_x,vela_adv_y,vela_adv_z,          &
                            vela_dif_x,vela_dif_y,vela_dif_z,          &
                            vela_mig_x,vela_mig_y,vela_mig_z,          &
                            vela_tot_x,vela_tot_y,vela_tot_z
        end if

      enddo
         
      return
      end subroutine tprfrtlc_faceflux
